<!DOCTYPE html><html lang="-en -zh-CN" data-default-color-scheme="auto"><head><meta name="google-site-verification" content="LXJ1yIUydqPx39hWuxwWHXx3-aKhuJQL2Ksk1JQVsZM"><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="https://github.com/user-attachments/assets/a867a61f-7adf-43e2-a511-c7ce204d93fd"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="HuaiYuan Jing"><meta name="keywords" content="HuaiYuan Jing"><meta name="description" content="1: Problem DescriptionAs stated, given a network graph with a source node and a sink node, calculate the maximum flow in the network. 1.1: Input FormatThe first line contains four positive integers: $"><meta property="og:type" content="article"><meta property="og:title" content="Network Flow"><meta property="og:url" content="https://huaiyuan-jing.github.io/posts/ea1c16df/index.html"><meta property="og:site_name" content="HuaiYuan&#39;s Programming Diary"><meta property="og:description" content="1: Problem DescriptionAs stated, given a network graph with a source node and a sink node, calculate the maximum flow in the network. 1.1: Input FormatThe first line contains four positive integers: $"><meta property="og:locale"><meta property="og:image" content="https://github.com/user-attachments/assets/9732f25e-9edd-45f4-b01a-44adc6d57d96"><meta property="article:published_time" content="2025-01-02T17:11:58.000Z"><meta property="article:modified_time" content="2025-09-05T21:53:20.947Z"><meta property="article:author" content="HuaiYuan Jing"><meta property="article:tag" content="Algorithm"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://github.com/user-attachments/assets/9732f25e-9edd-45f4-b01a-44adc6d57d96"><title>Network Flow - HuaiYuan&#39;s Programming Diary</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"huaiyuan-jing.github.io",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"https://github.com/user-attachments/assets/b9833017-4a11-4f4b-b6b1-d283c15bd656",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"IzubcGArkHkhcKX0ejKCF5tN-MdYXbMMI",app_key:"Jq398PJV3mcQVeeSc4ddYVbp",server_url:"https://izubcgar.api.lncldglobal.com",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="HuaiYuan's Programming Diary" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:50vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Programming Diary</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>Home</span></a></li><li class="nav-item"><a class="nav-link" href="/codelib" target="_self"><i class="iconfont icon-books"></i> <span>Codelib</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>Tag</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>About</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>Link</span></a></li><li class="nav-item"><a class="nav-link" href="https://itch.io/embed-upload/14850915" target="_self"><i class="iconfont icon-gitlab-fill"></i> <span>Fox</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://github.com/user-attachments/assets/9732f25e-9edd-45f4-b01a-44adc6d57d96) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.5)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Network Flow"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> HuaiYuan Jing </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-01-02 11:11" pubdate>Thursday, January 2nd 2025, 11:11 am</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>1.1k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>10 mins </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> times</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Network Flow</h1><div class="markdown-body"><h2 id="1-Problem-Description"><a href="#1-Problem-Description" class="headerlink" title="1: Problem Description"></a>1: Problem Description</h2><p>As stated, given a network graph with a source node and a sink node, calculate the maximum flow in the network.</p><h3 id="1-1-Input-Format"><a href="#1-1-Input-Format" class="headerlink" title="1.1: Input Format"></a>1.1: Input Format</h3><p>The first line contains four positive integers: $$n,m,s,t$$, representing the number of nodes, the number of directed edges, the source node index, and the sink node index, respectively.</p><p>The following mm lines each contain three positive integers: $u_i,v_i,w_i​$, representing the i-th directed edge starting from uiui​, ending at $v_i$​, with a weight $w_i$​ (indicating the maximum flow capacity of the edge).</p><h3 id="1-2-Output-Format"><a href="#1-2-Output-Format" class="headerlink" title="1.2: Output Format"></a>1.2: Output Format</h3><p>A single line containing a single positive integer, which is the maximum flow in the network.</p><h3 id="1-3-Example"><a href="#1-3-Example" class="headerlink" title="1.3: Example"></a>1.3: Example</h3><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">4 5 4 3<br>4 2 30<br>4 3 20<br>2 3 20<br>2 1 30<br>1 3 30<br></code></pre></td></tr></table></figure><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">50<br></code></pre></td></tr></table></figure><h2 id="2-Solution-1-Edmonds–Karp-Algorithm"><a href="#2-Solution-1-Edmonds–Karp-Algorithm" class="headerlink" title="2: Solution 1: Edmonds–Karp Algorithm"></a>2: Solution 1: Edmonds–Karp Algorithm</h2><ol><li>Find a path from the source ss to the sink tt where all edges have remaining capacity ($capacity−flow&gt;0$). Such a path is called “connected.”</li><li>Determine the bottleneck capacity along this path as $Augment&#x3D;min⁡(capacity−flow)$.</li><li>Add the $Augment$ to the maxflow result</li><li>Repeat the previous steps until the algorithm cannot find any connected path from s to t</li></ol><h3 id="2-1-Code-Part"><a href="#2-1-Code-Part" class="headerlink" title="2.1: Code (Part)"></a>2.1: Code (Part)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs rust">.....<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">max_flow</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, s: <span class="hljs-type">usize</span>, t: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">flow</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-comment">// Reset for BFS</span><br>        <span class="hljs-keyword">self</span>.a.<span class="hljs-title function_ invoke__">fill</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">queue</span> = VecDeque::<span class="hljs-title function_ invoke__">new</span>();<br>        queue.<span class="hljs-title function_ invoke__">push_back</span>(s);<br>        <span class="hljs-keyword">self</span>.a[s] = INF;<br><br>        <span class="hljs-comment">// Perform BFS</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = queue.<span class="hljs-title function_ invoke__">pop_front</span>() &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(edges) = <span class="hljs-keyword">self</span>.graph.<span class="hljs-title function_ invoke__">get</span>(&amp;x) &#123;<br>                <span class="hljs-keyword">for</span> &amp;i <span class="hljs-keyword">in</span> edges &#123;<br>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">edge</span> = &amp;<span class="hljs-keyword">self</span>.edges[i];<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.a[edge.to] == <span class="hljs-number">0</span> &amp;&amp; edge.cap &gt; edge.flow &#123;<br>                        <span class="hljs-keyword">self</span>.p[edge.to] = <span class="hljs-title function_ invoke__">Some</span>(i);<br>                        <span class="hljs-keyword">self</span>.a[edge.to] = <span class="hljs-title function_ invoke__">min</span>(<span class="hljs-keyword">self</span>.a[x], edge.cap - edge.flow);<br>                        queue.<span class="hljs-title function_ invoke__">push_back</span>(edge.to);<br>                        <span class="hljs-keyword">if</span> edge.to == t &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.a[t] == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// No more augmenting path found</span><br>        &#125;<br><br>        <span class="hljs-comment">// Augment flow along the path</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">u</span> = t;<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(edge_index) = <span class="hljs-keyword">self</span>.p[u] &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">edge</span> = &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.edges[edge_index];<br>            edge.flow += <span class="hljs-keyword">self</span>.a[t];<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">reverse_edge_index</span> = edge_index ^ <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">self</span>.edges[reverse_edge_index].flow -= <span class="hljs-keyword">self</span>.a[t];<br>            u = edge.from;<br>        &#125;<br><br>        flow += <span class="hljs-keyword">self</span>.a[t];<br>    &#125;<br><br>    flow<br>&#125;<br>.....<br></code></pre></td></tr></table></figure><h3 id="2-2-Time-Complexity-Analysis"><a href="#2-2-Time-Complexity-Analysis" class="headerlink" title="2.2: Time Complexity Analysis"></a>2.2: Time Complexity Analysis</h3><ul><li>The time complexity of finding augment path for one time is $O(m)$</li><li>The upper limit of times of Augument is $O(nm)$</li><li>So the time complexity of this algorithm is $O(nm^2)$</li></ul><h2 id="3-Solution-2-Dinic-Algorithm"><a href="#3-Solution-2-Dinic-Algorithm" class="headerlink" title="3: Solution 2: Dinic Algorithm"></a>3: Solution 2: Dinic Algorithm</h2><p>The Dinic algorithm works by dividing the graph into layers and repeatedly finding augmenting paths to increase the flow. Here’s the main idea:</p><ol><li><p><strong>BFS Layering:</strong> First, perform a Breadth-First Search (BFS) to divide the graph into layers. The distance from a node uu to the source ss determines its layer. Remove edges where the flow is equal to or exceeds the capacity to create the “level graph” $G_L&#x3D;(V,E_L)$.</p></li><li><p><strong>Blocking Flow:</strong> In the level graph $G_L$​, find a maximal flow that cannot be further augmented. This is called the blocking flow.</p></li><li><p><strong>Repeat:</strong> Continue finding and adding blocking flows to the total flow until no augmenting path exists between the source s and the sink t.</p></li></ol><h3 id="3-1-Key-Optimization"><a href="#3-1-Key-Optimization" class="headerlink" title="3.1: Key Optimization"></a>3.1: Key Optimization</h3><p>While performing DFS to find blocking flows:</p><ul><li><p>If you encounter a node u where all outgoing edges are already saturated, skip u.</p></li><li><p>Maintain a pointer for each node uu to keep track of which edge to explore next. This prevents revisiting edges unnecessarily and improves efficiency.</p></li></ul><h3 id="3-2-Code-Part"><a href="#3-2-Code-Part" class="headerlink" title="3.2: Code (Part)"></a>3.2: Code (Part)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    to: <span class="hljs-type">usize</span>,<br>    nxt: <span class="hljs-type">usize</span>,<br>    cap: <span class="hljs-type">i32</span>,<br>    flow: <span class="hljs-type">i32</span>,<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MaxFlow</span> &#123;<br>    s: <span class="hljs-type">usize</span>,<br>    t: <span class="hljs-type">usize</span>,<br>    head: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">usize</span>&gt;,<br>    edge: <span class="hljs-type">Vec</span>&lt;Edge&gt;,<br>    maxflow: <span class="hljs-type">isize</span>,<br>    depth: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">usize</span>&gt;,<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">MaxFlow</span> &#123;<br>    <span class="hljs-comment">/// Creates a new `MaxFlow` instance with `n` nodes, source node `s`, and sink node `t`.</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(n: <span class="hljs-type">usize</span>, s: <span class="hljs-type">usize</span>, t: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            s,<br>            t,<br>            head: <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0x3f3f3f3f</span>; n],<br>            edge: <span class="hljs-built_in">vec!</span>[],<br>            maxflow: <span class="hljs-number">0</span>,<br>            depth: <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; n],<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/// Adds a directed edge from `from` to `to` with capacity `cap` to the flow network.</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// # Arguments</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// `from`: The node from which the edge originates.</span><br>    <span class="hljs-comment">/// `to`: The node to which the edge points.</span><br>    <span class="hljs-comment">/// `cap`: The capacity of the edge.</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_edge</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, from: <span class="hljs-type">usize</span>, to: <span class="hljs-type">usize</span>, cap: <span class="hljs-type">i32</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = <span class="hljs-keyword">self</span>.edge.<span class="hljs-title function_ invoke__">len</span>();<br>        <span class="hljs-keyword">self</span>.edge.<span class="hljs-title function_ invoke__">push</span>(Edge &#123;<br>            to,<br>            nxt: <span class="hljs-keyword">self</span>.head[from],<br>            cap,<br>            flow: <span class="hljs-number">0</span>,<br>        &#125;);<br>        <span class="hljs-keyword">self</span>.head[from] = m;<br>        <span class="hljs-keyword">self</span>.edge.<span class="hljs-title function_ invoke__">push</span>(Edge &#123;<br>            to: from,<br>            nxt: <span class="hljs-keyword">self</span>.head[to],<br>            cap: <span class="hljs-number">0</span>,<br>            flow: <span class="hljs-number">0</span>,<br>        &#125;);<br>        <span class="hljs-keyword">self</span>.head[to] = m + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">/// Performs a BFS traversal of the residual graph to mark static nodes and find a shortest path from the source `s` to the sink `t`.</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// Returns `true` if a path is found, and `false` otherwise.</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bfs</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">q</span> = std::collections::VecDeque::<span class="hljs-title function_ invoke__">new</span>();<br>        q.<span class="hljs-title function_ invoke__">push_back</span>(<span class="hljs-keyword">self</span>.s);<br>        <span class="hljs-keyword">self</span>.depth.<span class="hljs-title function_ invoke__">fill</span>(<span class="hljs-number">0x3f3f3f3f</span>);<br>        <span class="hljs-keyword">self</span>.depth[<span class="hljs-keyword">self</span>.s] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> !q.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">u</span> = q.<span class="hljs-title function_ invoke__">pop_front</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">e</span> = <span class="hljs-keyword">self</span>.head[u];<br>            <span class="hljs-keyword">while</span> e != <span class="hljs-number">0x3f3f3f3f</span> &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-keyword">self</span>.edge[e].to;<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.edge[e].flow &lt; <span class="hljs-keyword">self</span>.edge[e].cap &amp;&amp; <span class="hljs-keyword">self</span>.depth[v] &gt; <span class="hljs-keyword">self</span>.depth[u] + <span class="hljs-number">1</span> &#123;<br>                    <span class="hljs-keyword">self</span>.depth[v] = <span class="hljs-keyword">self</span>.depth[u] + <span class="hljs-number">1</span>;<br>                    q.<span class="hljs-title function_ invoke__">push_back</span>(v);<br>                &#125;<br>                e = <span class="hljs-keyword">self</span>.edge[e].nxt;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">self</span>.depth[<span class="hljs-keyword">self</span>.t] != <span class="hljs-number">0x3f3f3f3f</span><br>    &#125;<br>    <span class="hljs-comment">/// Performs a DFS traversal of the residual graph to find a path from node `u` to the sink `t`.</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// Returns the maximum flow that can be pushed along the path.</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// # Arguments</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// `u`: The starting node of the path.</span><br>    <span class="hljs-comment">/// `flow`: The maximum flow to be pushed along the path.</span><br>    <span class="hljs-comment">/// `edges`: The vector of edges in the residual graph.</span><br>    <span class="hljs-comment">/// `cur`: The vector of current edges for each node in the residual graph.</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dfs</span>(&amp;<span class="hljs-keyword">self</span>, u: <span class="hljs-type">usize</span>, flow: <span class="hljs-type">i32</span>, edges: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;Edge&gt;, cur: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">usize</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-keyword">if</span> u == <span class="hljs-keyword">self</span>.t || flow == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> flow;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">res</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">e</span> = cur[u];<br>        <span class="hljs-keyword">while</span> e != <span class="hljs-number">0x3f3f3f3f</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = edges[e].to;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.depth[v] == <span class="hljs-keyword">self</span>.depth[u] + <span class="hljs-number">1</span> &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">dfs</span>(<br>                    v,<br>                    std::cmp::<span class="hljs-title function_ invoke__">min</span>(flow - res, edges[e].cap - edges[e].flow),<br>                    edges,<br>                    cur,<br>                );<br>                edges[e].flow += f;<br>                edges[e ^ <span class="hljs-number">1</span>].flow -= f;<br>                res += f;<br>                <span class="hljs-keyword">if</span> res == flow &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            e = <span class="hljs-keyword">self</span>.edge[e].nxt;<br>            cur[u] = e;<br>        &#125;<br>        res<br>    &#125;<br>    <span class="hljs-comment">/// Computes the maximum flow in the flow network using the Dinic&#x27;s algorithm.</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// This function repeatedly calls `bfs` to find a shortest augmenting path</span><br>    <span class="hljs-comment">/// and `dfs` to augment the flow along the path. The maximum flow is</span><br>    <span class="hljs-comment">/// accumulated in `maxflow` field.</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dinic</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">bfs</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cur</span> = <span class="hljs-keyword">self</span>.head.<span class="hljs-title function_ invoke__">clone</span>();<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">edge</span> = <span class="hljs-keyword">self</span>.edge.<span class="hljs-title function_ invoke__">clone</span>();<br>            <span class="hljs-keyword">self</span>.maxflow += <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">dfs</span>(<span class="hljs-keyword">self</span>.s, std::<span class="hljs-type">i32</span>::MAX, &amp;<span class="hljs-keyword">mut</span> edge, &amp;<span class="hljs-keyword">mut</span> cur) <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>;<br>            <span class="hljs-keyword">self</span>.edge = edge;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Soluiton-3-ISAP-Algorithmn"><a href="#4-Soluiton-3-ISAP-Algorithmn" class="headerlink" title="4: Soluiton 3: ISAP Algorithmn"></a>4: Soluiton 3: ISAP Algorithmn</h2><ol><li><p>Perform a BFS from t to s and mark the depth (why it’s from t to s will be explained later).</p></li><li><p>Perform a DFS from s to t, similar to Dinic’s algorithm. However, after finishing processing a node, if the flow passed from the previous node exceeds the used capacity of the current node (for the current depth), the current node is considered “wasted” for the remaining path. In this case, increment its depth by 1. If a gap (a depth level with no nodes) appears, terminate the algorithm.</p></li><li><p>If step 2 does not terminate the algorithm, repeat step 2.</p></li></ol><h3 id="4-1-Optimization"><a href="#4-1-Optimization" class="headerlink" title="4.1: Optimization"></a>4.1: Optimization</h3><p>Compare to Dinic Algorithm, ISAP doesnt require to run bfs several times.</p><h3 id="4-2-Code-Part"><a href="#4-2-Code-Part" class="headerlink" title="4.2: Code (Part)"></a>4.2: Code (Part)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> maxflow &#123;<br>    <span class="hljs-meta">#[derive(Clone)]</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>        to: <span class="hljs-type">usize</span>,<br>        nxt: <span class="hljs-type">usize</span>,<br>        cap: <span class="hljs-type">i32</span>,<br>        flow: <span class="hljs-type">i32</span>,<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Graph</span> &#123;<br>        n: <span class="hljs-type">usize</span>,<br>        s: <span class="hljs-type">usize</span>,<br>        t: <span class="hljs-type">usize</span>,<br>        head: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">usize</span>&gt;,<br>        edge: <span class="hljs-type">Vec</span>&lt;Edge&gt;,<br>        <span class="hljs-keyword">pub</span> maxflow: <span class="hljs-type">isize</span>,<br>        depth: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">usize</span>&gt;,<br>        gap: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">usize</span>&gt;,<br>    &#125;<br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Graph</span> &#123;<br>        <span class="hljs-comment">/// Creates a new `MaxFlow` instance with `n` nodes, source node `s`, and sink node `t`.</span><br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(n: <span class="hljs-type">usize</span>, s: <span class="hljs-type">usize</span>, t: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>            <span class="hljs-keyword">Self</span> &#123;<br>                n,<br>                s,<br>                t,<br>                head: <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0x3f3f3f3f</span>; n],<br>                edge: <span class="hljs-built_in">vec!</span>[],<br>                maxflow: <span class="hljs-number">0</span>,<br>                depth: <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0x3f3f3f3f</span>; n],<br>                gap: <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; n * <span class="hljs-number">2</span>],<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/// Adds a directed edge from `from` to `to` with capacity `cap` to the flow network.</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// # Arguments</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// `from`: The node from which the edge originates.</span><br>    <span class="hljs-comment">/// `to`: The node to which the edge points.</span><br>    <span class="hljs-comment">/// `cap`: The capacity of the edge.</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_edge</span>(g: &amp;<span class="hljs-keyword">mut</span> Graph, from: <span class="hljs-type">usize</span>, to: <span class="hljs-type">usize</span>, cap: <span class="hljs-type">i32</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = g.edge.<span class="hljs-title function_ invoke__">len</span>();<br>        g.edge.<span class="hljs-title function_ invoke__">push</span>(Edge &#123;<br>            to,<br>            nxt: g.head[from],<br>            cap,<br>            flow: <span class="hljs-number">0</span>,<br>        &#125;);<br>        g.head[from] = m;<br>        g.edge.<span class="hljs-title function_ invoke__">push</span>(Edge &#123;<br>            to: from,<br>            nxt: g.head[to],<br>            cap: <span class="hljs-number">0</span>,<br>            flow: <span class="hljs-number">0</span>,<br>        &#125;);<br>        g.head[to] = m + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">/// Performs a BFS traversal of the residual graph to mark static nodes and find a shortest path from the source `s` to the sink `t`.</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// Returns `true` if a path is found, and `false` otherwise.</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">generate_depth</span>(g: &amp;<span class="hljs-keyword">mut</span> Graph) &#123;<br>        g.depth = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0x3f3f3f3f</span>; g.n];<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">q</span> = std::collections::VecDeque::<span class="hljs-title function_ invoke__">new</span>();<br>        q.<span class="hljs-title function_ invoke__">push_back</span>(g.t);<br>        g.depth[g.t] = <span class="hljs-number">0</span>;<br>        g.gap[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> !q.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">u</span> = q.<span class="hljs-title function_ invoke__">pop_front</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">e</span> = g.head[u];<br>            <span class="hljs-keyword">while</span> e != <span class="hljs-number">0x3f3f3f3f</span> &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = g.edge[e].to;<br>                <span class="hljs-keyword">if</span> g.depth[v] != <span class="hljs-number">0x3f3f3f3f</span> &#123;<br>                    e = g.edge[e].nxt;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                g.depth[v] = g.depth[u] + <span class="hljs-number">1</span>;<br>                g.gap[g.depth[v]] += <span class="hljs-number">1</span>;<br>                q.<span class="hljs-title function_ invoke__">push_back</span>(v);<br>                e = g.edge[e].nxt;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/// Performs a DFS traversal of the residual graph to find a path from node `u` to the sink `t`.</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// Returns the maximum flow that can be pushed along the path.</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// # Arguments</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// `u`: The starting node of the path.</span><br>    <span class="hljs-comment">/// `flow`: The maximum flow to be pushed along the path.</span><br>    <span class="hljs-comment">/// `edges`: The vector of edges in the residual graph.</span><br>    <span class="hljs-comment">/// `cur`: The vector of current edges for each node in the residual graph.</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dfs</span>(g: &amp;<span class="hljs-keyword">mut</span> Graph, u: <span class="hljs-type">usize</span>, flow: <span class="hljs-type">i32</span>, cur: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">usize</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-keyword">if</span> u == g.t || flow == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> flow;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">used</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">e</span> = cur[u];<br>        <span class="hljs-keyword">while</span> e != <span class="hljs-number">0x3f3f3f3f</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = g.edge[e].to;<br>            <span class="hljs-keyword">if</span> g.depth[v] == g.depth[u] - <span class="hljs-number">1</span> &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-title function_ invoke__">dfs</span>(<br>                    g,<br>                    v,<br>                    std::cmp::<span class="hljs-title function_ invoke__">min</span>(flow - used, g.edge[e].cap - g.edge[e].flow),<br>                    cur,<br>                );<br>                g.edge[e].flow += f;<br>                g.edge[e ^ <span class="hljs-number">1</span>].flow -= f;<br>                used += f;<br>                <span class="hljs-keyword">if</span> used == flow &#123;<br>                    <span class="hljs-keyword">return</span> used;<br>                &#125;<br>            &#125;<br>            e = g.edge[e].nxt;<br>            cur[u] = e;<br>        &#125;<br>        g.gap[g.depth[u]] -= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> g.gap[g.depth[u]] == <span class="hljs-number">0</span> &#123;<br>            g.depth[g.s] = g.n + <span class="hljs-number">1</span>;<br>        &#125;<br>        g.depth[u] += <span class="hljs-number">1</span>;<br>        g.gap[g.depth[u]] += <span class="hljs-number">1</span>;<br>        used<br>    &#125;<br>    <span class="hljs-comment">/// Computes the maximum flow in the flow network using the Dinic&#x27;s algorithm.</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// This function repeatedly calls `bfs` to find a shortest augmenting path</span><br>    <span class="hljs-comment">/// and `dfs` to augment the flow along the path. The maximum flow is</span><br>    <span class="hljs-comment">/// accumulated in `maxflow` field.</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">isap</span>(g: &amp;<span class="hljs-keyword">mut</span> Graph) &#123;<br>        <span class="hljs-title function_ invoke__">generate_depth</span>(g);<br>        <span class="hljs-keyword">while</span> g.depth[g.s] &lt; g.n &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cur</span> = g.head.<span class="hljs-title function_ invoke__">clone</span>();<br>            g.maxflow += <span class="hljs-title function_ invoke__">dfs</span>(g, g.s, std::<span class="hljs-type">i32</span>::MAX, &amp;<span class="hljs-keyword">mut</span> cur) <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Algorithm/" class="print-no-link">#Algorithm</a></div></div><div class="license-box my-3"><div class="license-title"><div>Network Flow</div><div>https://huaiyuan-jing.github.io/posts/ea1c16df/</div></div><div class="license-meta"><div class="license-meta-item"><div>Beitragsautor</div><div>HuaiYuan Jing</div></div><div class="license-meta-item license-meta-date"><div>Veröffentlicht am</div><div>January 2, 2025</div></div><div class="license-meta-item"><div>Urheberrechtshinweis</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/e600f8d3/" title="量子纠错: Shor Code"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">量子纠错: Shor Code</span> <span class="visible-mobile">Vorheriger</span></a></article><article class="post-next col-6"><a href="/posts/d1d01c28/" title="Basic Reverse Engineering by using GDB"><span class="hidden-mobile">Basic Reverse Engineering by using GDB</span> <span class="visible-mobile">Nächster</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="gitalk-container"></div><script type="text/javascript">Fluid.utils.loadComments("#gitalk-container",(function(){Fluid.utils.createCssLink("/css/gitalk.css"),Fluid.utils.createScript("https://lib.baomitu.com/gitalk/1.8.0/gitalk.min.js",(function(){var a=Object.assign({clientID:"Ov23li2yI04wDQ7Iy4xP",clientSecret:"d89a07029a388e53e47b4ab798955aaab2557e28",repo:"huaiyuan-jing.github.io",owner:"Huaiyuan-Jing",admin:"Huaiyuan-Jing",language:"en",labels:["Gitalk"],perPage:10,pagerDirection:"last",distractionFreeMode:!1,createIssueManually:!1,proxy:"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},{id:"3799aac97cbf20205c138245eb3c5f88"});new Gitalk(a).render("gitalk-container")}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>Inhaltsverzeichnis</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Suchen</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Stichwort</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">Total Visited <span id="leancloud-site-pv"></span> Times </span><span id="leancloud-site-uv-container" style="display:none">Total <span id="leancloud-site-uv"></span> Unique Visitors</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog funktioniert am besten mit aktiviertem JavaScript</div></noscript></body></html>